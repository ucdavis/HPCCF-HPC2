#!/bin/bash

echo "Configuring..."
echo "#Generated by configure script. Do not add to svn." > .make.config

if [ -z "$F90" ]; then
  echo "ERROR:"
  echo "You have not set your Fortran compiler (the F90 environment variable)."
  echo "try using: "
  echo "F90=ifort ./configure"
  echo "or"
  echo "F90=gfortran ./configure"
  echo "or"
  echo "F90=f95 ./configure"
  exit
fi

make clean

# Right now we just need to set the LIBS variable in the makefile: the
# Fortran linker cannot automagically find the c++ library we need,
# so we have to hold its hand a bit.
if [ -e /etc/ld.so.conf ]; then
  # Strictly speaking this looks for locations where dynamic libraries
  # are stored, but 99% of the time the static libraries are there as
  # well. Someday I will find a better way of doing this.
  libs=`cat /etc/ld.so.conf | grep "^/"`
  for lib in $libs; do
    liblist="$liblist -L$lib"
  done
fi
# Figure out our C compiler version:
version=`$CC --version 2>&1 | grep -e "[1-9]\.[0-9]\.[0-9]" | sed -e "s/.*\([1-9]\.[0-9]\.[0-9]\).*/\1/" `
if [ -z "$version" ]; then
  # Maybe it's a 2.96-type version?
  version=`$CC --version 2>&1 | grep -e "[1-9]\.[0-9][0-9]" | sed -e "s/.*\([1-9]\.[0-9][0-9]\).*/\1/" `
  if [ -z "$version" ]; then
    version="/"
  fi
fi

# Non-linux systems (i.e. Cygwin) do not have an ld.so.conf file,
# or a close equivalent. We need to find out where stdc++ is located,
# so try a "find" -- this will not necessarily give the one the user
# wants, since there is no way to specify the search order. Cross
# your fingers:
search_paths="/usr/lib /usr/lib32 /usr/lib64 /usr/lib-gcc /usr/gcc-lib/"
for path in $search_paths; do
  libs=`find $path -name "libstdc++.a" 2> /dev/null` 
  for lib in $libs; do
    check_version=`echo $lib | grep "$version"`
    if [ -n "$check_version" ]; then
      # Strip off the name of the library, leaving just the directory:
      liblist="$liblist -L`dirname $lib`"
    fi
  done
done
echo "LIBS = $liblist -lm -lstdc++" >> .make.config

# The next thing to check is whether their fortran compiler supports
# the BINARY keyword: try to compile a simple program:
echo -e "PROGRAM main" > bintest.f90
echo -e " OPEN (UNIT=100,FORM='BINARY') " >> bintest.f90
echo -e "END" >> bintest.f90
$F90 $FFLAGS $F90FLAGS -o bintest bintest.f90 > /dev/null 2>&1
if [ -x bintest ]; then
  result=`./bintest 2>&1 | grep -i "err"`
  if [ -z "$result" ]; then
    echo "IO_MODULE= LinuxBinaryIO.o" >> .make.config
  else
    echo "IO_MODULE= cio.o LinuxIO.o" >> .make.config
  fi
  rm bintest
else
  echo "IO_MODULE= cio.o LinuxIO.o" >> .make.config
fi
rm -f bintest.f90 bintest.o
echo "F90=$F90" >> .make.config
echo "CC=$CC" >> .make.config
echo $F90 > .compiler

if [ -z "$FFLAGS" ]; then
  case $F90 in
    ifort )    FFLAGS="-O2 -g -static -implicitnone -traceback";;
    f95 )      FFLAGS="-YEXT_NAMES=LCS -s -B108 -YCFRL=1 -et -Rb -Rc -Rs -m3 -Rp -cpu:host -O2";;
    gfortran ) FFLAGS="-O2 -g -static";;
    g95 )      FFLAGS="-O2 -g -static";;
    pgf* )      FFLAGS="-O2 -g";;
    mpi* )     echo "For parallel compilation, you must manually set FFLAGS in .make.config.";;
    * )        echo "Unrecognized compiler. You may need to edit .make.config.";;
  esac
fi

case $F90 in
  mpi* )    MPIModule="parallelMPIModule.o";;
  * )       MPIModule="serialMPIModule.o";;
esac

echo "FFLAGS=$FFLAGS" >> .make.config
echo "MPIModule=$MPIModule" >> .make.config

if [ -n "$CFLAGS" ]; then
  echo "CFLAGS=$CFLAGS" >> .make.config
else
  echo "CFLAGS=-O2 -g" >> .make.config  # Default CFLAGS
fi

echo "FFT_SUFFIX=`echo "$F90" | sed -e "s/[^a-zA-Z0-9]/_/g"`" >> .make.config


echo "Done. Run make to compile PSU-WOPWOP."
